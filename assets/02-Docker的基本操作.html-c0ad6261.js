import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as r,c as t,a as e,b as a,d as s,e as n}from"./app-9eb6622e.js";const d={},o=n('<h2 id="一、镜像操作" tabindex="-1"><a class="header-anchor" href="#一、镜像操作" aria-hidden="true">#</a> 一、镜像操作</h2><h3 id="_1-镜像名称" tabindex="-1"><a class="header-anchor" href="#_1-镜像名称" aria-hidden="true">#</a> 1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200134296.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p><h3 id="_2-镜像命令" tabindex="-1"><a class="header-anchor" href="#_2-镜像命令" aria-hidden="true">#</a> 2.镜像命令</h3><p>常见的镜像操作命令如图：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200134503.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-案例1-拉取、查看镜像" tabindex="-1"><a class="header-anchor" href="#_3-案例1-拉取、查看镜像" aria-hidden="true">#</a> 3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>',12),c={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},u=n(`<figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200134392.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200134692.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）通过命令：docker images 查看拉取到的镜像</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200134697.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-案例2-保存、导入镜像" tabindex="-1"><a class="header-anchor" href="#_4-案例2-保存、导入镜像" aria-hidden="true">#</a> 4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>（1）利用docker xx --help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135768.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>命令格式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> <span class="token punctuation">[</span>保存的目标文件名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）使用docker save导出镜像到磁盘</p><p>运行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> nginx.tar nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果如图：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135308.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后运行命令，加载本地文件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> load <span class="token parameter variable">-i</span> nginx.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135293.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-练习" tabindex="-1"><a class="header-anchor" href="#_5-练习" aria-hidden="true">#</a> 5.练习</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><ul><li>去DockerHub搜索Redis镜像</li><li>查看Redis镜像的名称和版本</li><li>利用docker pull命令拉取镜像</li><li>利用docker save命令将 redis:latest打包为一个redis.tar包</li><li>利用docker rmi 删除本地的redis:latest</li><li>利用docker load 重新加载 redis.tar文件</li></ul><h2 id="二、容器操作" tabindex="-1"><a class="header-anchor" href="#二、容器操作" aria-hidden="true">#</a> 二、容器操作</h2><h3 id="_1-容器相关命令" tabindex="-1"><a class="header-anchor" href="#_1-容器相关命令" aria-hidden="true">#</a> 1.容器相关命令</h3><p>容器操作的命令如图：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135142.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="_2-案例-创建并运行一个容器" tabindex="-1"><a class="header-anchor" href="#_2-案例-创建并运行一个容器" aria-hidden="true">#</a> 2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> containerName <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>--name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135031.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-案例-进入容器-修改文件" tabindex="-1"><a class="header-anchor" href="#_3-案例-进入容器-修改文件" aria-hidden="true">#</a> 3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>（1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mn <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li>docker exec ：进入容器内部，执行一个命令</li><li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li>mn ：要进入的容器的名称</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul><p>（2）进入nginx的HTML所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135629.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/share/nginx/html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看目录下文件：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200135879.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#Welcome to nginx#传智教育欢迎您#g&#39;</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#39;</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,67),g={href:"http://192.168.150.101",target:"_blank",rel:"noopener noreferrer"},h=n(`<figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136261.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-小结" tabindex="-1"><a class="header-anchor" href="#_4-小结" aria-hidden="true">#</a> 4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>--name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="三、数据卷-容器数据管理" tabindex="-1"><a class="header-anchor" href="#三、数据卷-容器数据管理" aria-hidden="true">#</a> 三、数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136585.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="_1-什么是数据卷" tabindex="-1"><a class="header-anchor" href="#_1-什么是数据卷" aria-hidden="true">#</a> 1.什么是数据卷</h3><p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136155.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><h3 id="_2-数据集操作命令" tabindex="-1"><a class="header-anchor" href="#_2-数据集操作命令" aria-hidden="true">#</a> 2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h3 id="_3-创建和查看数据卷" tabindex="-1"><a class="header-anchor" href="#_3-创建和查看数据卷" aria-hidden="true">#</a> 3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>（1）创建数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）查看所有数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136515.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>（3）查看数据卷详细信息卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume inspect html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136786.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="_4-挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_4-挂载数据卷" aria-hidden="true">#</a> 4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> mn <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> html:/root/html <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80
  nginx <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><h3 id="_5-案例-给nginx挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_5-案例-给nginx挂载数据卷" aria-hidden="true">#</a> 5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>（1）创建容器并挂载数据卷到容器内的HTML目录</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mn <span class="token parameter variable">-v</span> html:/usr/share/nginx/html <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）进入html数据卷所在位置，并修改HTML内容</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看html数据卷的位置</span>
<span class="token function">docker</span> volume inspect html
<span class="token comment"># 进入该目录</span>
<span class="token builtin class-name">cd</span> /var/lib/docker/volumes/html/_data
<span class="token comment"># 修改文件</span>
<span class="token function">vi</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-案例-给mysql挂载本地目录" tabindex="-1"><a class="header-anchor" href="#_6-案例-给mysql挂载本地目录" aria-hidden="true">#</a> 6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 ---&gt; 容器内目录</li></ul><p>如图：</p><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/202308200136466.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>（1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>（2）创建目录/tmp/mysql/data</p><p>（3）创建目录/tmp/mysql/conf，将课前资料提供的hmy.cnf文件上传到/tmp/mysql/conf</p><p>（4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><pre><code>• 挂载/tmp/mysql/data到mysql容器内数据存储目录
• 挂载/tmp/mysql/conf/hmy.cnf到mysql容器的配置文件
• 设置MySQL密码
</code></pre><h3 id="_7-小结" tabindex="-1"><a class="header-anchor" href="#_7-小结" aria-hidden="true">#</a> 7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul>`,75);function m(b,v){const i=p("ExternalLinkIcon");return r(),t("div",null,[o,e("p",null,[a("（1）首先去镜像仓库搜索nginx镜像，比如"),e("a",c,[a("DockerHub"),s(i)]),a(":")]),u,e("p",null,[a("在浏览器访问自己的虚拟机地址，例如我的是："),e("a",g,[a("http://192.168.150.101"),s(i)]),a("，即可看到结果：")]),h])}const x=l(d,[["render",m],["__file","02-Docker的基本操作.html.vue"]]);export{x as default};
