import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as d,d as i}from"./app-42cc0bba.js";const a={},n=i(`<h2 id="新建启动容器" tabindex="-1"><a class="header-anchor" href="#新建启动容器" aria-hidden="true">#</a> 新建启动容器</h2><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常用的参数：</p><ul><li><code>--name</code>：为容器指定一个名称</li><li><code>-d</code>：后台运行容器并返回容器ID，也即启动守护式容器</li><li><code>-i</code>：以交互模式（interactive）运行容器，通常与-t同时使用</li><li><code>-t</code>：为容器重新分配一个伪输入终端（tty），通常与-i同时使用。也即启动交互式容器（前台有伪终端，等待交互）</li><li><code>-e</code>：为容器添加环境变量</li><li><code>-P</code>：随机端口映射。将容器内暴露的所有端口映射到宿主机随机端口</li><li><code>-p</code>：指定端口映射</li></ul><p><code>-p</code>指定端口映射的几种不同形式：</p><ul><li><code>-p hostPort:containerPort</code>：端口映射，例如-p 8080:80</li><li><code>-p ip:hostPort:containerPort</code>：配置监听地址，例如 -p 10.0.0.1:8080:80</li><li><code>-p ip::containerPort</code>：随机分配端口，例如 -p 10.0.0.1::80</li><li><code>-p hostPort1:containerPort1 -p hostPort2:containerPort2</code>：指定多个端口映射，例如<code>-p 8080:80 -p 8888:3306</code></li></ul><h2 id="启动交互式容器" tabindex="-1"><a class="header-anchor" href="#启动交互式容器" aria-hidden="true">#</a> 启动交互式容器</h2><p>以交互方式启动ubuntu镜像</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code># -i 交互模式
# -t 分配一个伪输入终端tty
# ubuntu 镜像名称
# /bin/bash（或者bash） shell交互的接口
docker run -it ubuntu /bin/bash
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>退出交互模式：</p><p>方式1：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code># 在交互shell中exit即可退回宿主机
exit;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>方式2：使用快捷键Ctrl + P + Q</p><p>方式1 退出后，容器会停止；</p><p>方式2 退出后容器依然正在运行。</p><h2 id="启动守护式容器" tabindex="-1"><a class="header-anchor" href="#启动守护式容器" aria-hidden="true">#</a> 启动守护式容器</h2><p>大部分情况下，我们系统docker容器服务时在后台运行的，可以通过-d指定容器的后台运行模式：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker run -d 容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意事项：</p><p>如果使用docker run -d ubuntu尝试启动守护式的ubuntu，会发现容器启动后就自动退出了。</p><p>因为Docker容器如果在后台运行，就必须要有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（例如top、tail），就会自动退出。</p><h2 id="列出正在运行的容器" tabindex="-1"><a class="header-anchor" href="#列出正在运行的容器" aria-hidden="true">#</a> 列出正在运行的容器</h2><p>列出所有正在运行的容器：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker ps [OPTIONS]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常用参数：</p><ul><li><code>-a</code>：列出当前所有正在运行的容器+历史上运行过的容器</li><li><code>-l</code>：显示最近创建的容器</li><li><code>-n</code>：显示最近n个创建的容器</li><li><code>-q</code>：静默模式，只显示容器编号</li></ul><h2 id="容器其他启停操作" tabindex="-1"><a class="header-anchor" href="#容器其他启停操作" aria-hidden="true">#</a> 容器其他启停操作</h2><p>启动已经停止的容器</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker start 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重启容器</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker restart 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>停止容器</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker stop 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>强制停止容器</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker kill 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="删除容器" tabindex="-1"><a class="header-anchor" href="#删除容器" aria-hidden="true">#</a> 删除容器</h2><p>删除已经停止的容器：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker rm 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>删除容器是 docker rm，删除镜像是 docker rmi，注意区分。</p><p>强制删除正在运行的容器：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker rm -f 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一次删除多个容器实例：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker rm -f $(docker ps -a -q)

# 或者
docker ps -a -q | xargs docker rm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="查看容器日志" tabindex="-1"><a class="header-anchor" href="#查看容器日志" aria-hidden="true">#</a> 查看容器日志</h2><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker logs 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="查看容器内运行的进程" tabindex="-1"><a class="header-anchor" href="#查看容器内运行的进程" aria-hidden="true">#</a> 查看容器内运行的进程</h2><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker top 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="查看容器内部细节" tabindex="-1"><a class="header-anchor" href="#查看容器内部细节" aria-hidden="true">#</a> 查看容器内部细节</h2><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker inspect 容器ID或容器名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="进入正在运行的容器" tabindex="-1"><a class="header-anchor" href="#进入正在运行的容器" aria-hidden="true">#</a> 进入正在运行的容器</h2><p>进入正在运行的容器，并以命令行交互：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker exec -it 容器ID bashShell
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重新进入：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker attach 容器ID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker exec 和 docker attach 区别：</p><ul><li>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出会导致容器的停止</li><li>exec是在容器中打开新的终端，并且可以启动新的进程，用exit退出不会导致容器的停止</li></ul><p>如果有多个终端，都对同一个容器执行了 docker attach，就会出现类似投屏显示的效果。一个终端中输入输出的内容，在其他终端上也会同步的显示。</p><h2 id="容器和宿主机文件拷贝" tabindex="-1"><a class="header-anchor" href="#容器和宿主机文件拷贝" aria-hidden="true">#</a> 容器和宿主机文件拷贝</h2><p>容器内文件拷贝到宿主机：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker cp 容器ID:容器内路径 目的主机路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>宿主机文件拷贝到容器中：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker cp 主机路径 容器ID:容器内路径
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="导入和导出容器" tabindex="-1"><a class="header-anchor" href="#导入和导出容器" aria-hidden="true">#</a> 导入和导出容器</h2><p>export：导出容器的内容流作为一个tar归档文件（对应import命令）；</p><p>import：从tar包中的内容创建一个新的文件系统再导入为镜像（对应export命令）；</p><p>示例：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code># 导出
# docker export 容器ID &gt; tar文件名
docker export abc &gt; aaa.tar

# 导入
# cat tar文件 | docker import -自定义镜像用户/自定义镜像名:自定义镜像版本号
cat aaa.tar | docker import -test/mytest:1.0.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="将容器生成新镜像" tabindex="-1"><a class="header-anchor" href="#将容器生成新镜像" aria-hidden="true">#</a> 将容器生成新镜像</h2><p>docker commit提交容器副本使之成为一个新的镜像。</p><p>docker 启动一个镜像容器后， 可以在里面执行一些命令操作，然后使用docker commit将新的这个容器快照生成一个镜像。</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[tag]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Docker挂载主机目录，可能会出现报错：cannot open directory .: Perission denied。</p><p>解决方案：在命令中加入参数 --privileged=true。</p><p>CentOS7安全模块比之前系统版本加强，不安全的会先禁止，目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了。如果要开启，一般使用 --privileged=true，扩大容器的权限解决挂载没有权限的问题。也即使用该参数，容器内的root才拥有真正的root权限，否则容器内的root只是外部的一个普通用户权限。</p><h2 id="容器数据卷" tabindex="-1"><a class="header-anchor" href="#容器数据卷" aria-hidden="true">#</a> 容器数据卷</h2><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过UnionFS，提供一些用于持续存储或共享数据。</p><p>特性：卷设计的目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><ul><li>数据卷可以在容器之间共享或重用数据</li><li>卷中的更改可以直接实施生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p>运行一个带有容器卷存储功能的容器实例：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code>docker run -it --privileged=true -v 宿主机绝对路径目录:容器内目录[rw | ro] 镜像名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以使用docker inspect查看容器绑定的数据卷。</p><p>权限：</p><ul><li>rw：读写</li><li>ro：只读。如果宿主机写入内容，可以同步给容器内，容器内可以读取。</li></ul><p>容器卷的继承：</p><div class="language-Shell line-numbers-mode" data-ext="Shell"><pre class="language-Shell"><code># 启动一个容器
docker run -it --privileged=true /tmp/test:/tmp/docker --name u1 ubuntu /bin/bash

# 使用 --volumes-from 继承 u1的容器卷映射配置
docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="所有命令示意图" tabindex="-1"><a class="header-anchor" href="#所有命令示意图" aria-hidden="true">#</a> 所有命令示意图</h2><figure><img src="https://lhplanet-1316168555.cos.ap-beijing.myqcloud.com/obsidian/20231024111354.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,88),r=[n];function s(c,o){return l(),d("div",null,r)}const h=e(a,[["render",s],["__file","05-容器命令.html.vue"]]);export{h as default};
